#!/usr/bin/env python3
"""
Enochian Cyphers Governor Quest Generation System

Uses AI embodiments of the 91 Governor Angels to generate personalized
questlines that reflect each governor's unique personality and knowledge base.
"""

import json
import asyncio
import logging
from typing import Dict, List, Any, Optional
from dataclasses import dataclass
from datetime import datetime
import random
from pathlib import Path

from governor_ai_embodiment import GovernorAIEmbodiment, GovernorKnowledge

logger = logging.getLogger(__name__)

@dataclass
class Quest:
    """Represents a single quest generated by a governor"""
    id: str
    governor_name: str
    title: str
    description: str
    difficulty_level: int  # 1-30
    energy_cost: int  # 1-6
    reputation_reward: int
    required_reputation: int
    tradition_focus: str
    quest_type: str
    mystical_elements: List[str]
    completion_criteria: List[str]
    failure_consequences: List[str]
    authentic_content: str  # Rich content from lighthouse
    personality_flavor: str  # Governor's unique perspective

@dataclass
class QuestTree:
    """Complete quest tree for a governor (75-125 quests)"""
    governor_name: str
    total_quests: int
    quests: List[Quest]
    difficulty_distribution: Dict[str, int]
    tradition_distribution: Dict[str, int]
    quest_type_distribution: Dict[str, int]

class GovernorQuestGenerator:
    """Generates authentic questlines for each governor"""
    
    def __init__(self, embodiment_system: GovernorAIEmbodiment):
        self.embodiment_system = embodiment_system
        self.quest_trees = {}
        
        # Quest type templates
        self.quest_types = {
            'meditation': {
                'name': 'Meditation',
                'description_template': 'Enter deep meditative communion with {element} energies',
                'base_energy_cost': 1,
                'base_difficulty': 5
            },
            'ritual': {
                'name': 'Ritual',
                'description_template': 'Perform sacred ritual drawing upon {tradition} practices',
                'base_energy_cost': 2,
                'base_difficulty': 10
            },
            'study': {
                'name': 'Study',
                'description_template': 'Undertake comprehensive study of {tradition} mysteries',
                'base_energy_cost': 1,
                'base_difficulty': 8
            },
            'divination': {
                'name': 'Divination',
                'description_template': 'Seek oracular wisdom through {divination_method}',
                'base_energy_cost': 2,
                'base_difficulty': 12
            },
            'service': {
                'name': 'Service',
                'description_template': 'Serve others through application of {tradition} wisdom',
                'base_energy_cost': 3,
                'base_difficulty': 15
            },
            'creation': {
                'name': 'Creation',
                'description_template': 'Create sacred work expressing {tradition} principles',
                'base_energy_cost': 3,
                'base_difficulty': 18
            },
            'teaching': {
                'name': 'Teaching',
                'description_template': 'Teach {tradition} principles to fellow seekers',
                'base_energy_cost': 4,
                'base_difficulty': 22
            },
            'mastery': {
                'name': 'Mastery',
                'description_template': 'Demonstrate mastery of {tradition} through advanced practice',
                'base_energy_cost': 5,
                'base_difficulty': 25
            }
        }
        
        # Aethyr difficulty modifiers
        self.aethyr_modifiers = {
            'TEX': 2.5, 'ARN': 2.3, 'ZOM': 2.1, 'PAZ': 1.9,  # Transcendence tier
            'LIT': 1.8, 'MAZ': 1.6, 'DEO': 1.5, 'ZID': 1.4,  # Mastery tier
            'ZIP': 1.3, 'ZAX': 1.2, 'ICH': 1.1, 'LOE': 1.0,  # Development tier
            'ZIM': 0.9, 'UTA': 0.8, 'OXO': 0.7, 'LEA': 0.6,  # Foundation tier
        }
    
    def generate_quest_tree(self, governor_name: str, target_quest_count: Optional[int] = None) -> Optional[QuestTree]:
        """Generate complete quest tree for a governor"""
        embodiment = self.embodiment_system.get_embodiment(governor_name)
        if not embodiment:
            logger.error(f"No embodiment found for {governor_name}")
            return None
            
        # Determine quest count (75-125 range)
        if target_quest_count is None:
            # Use governor name hash for deterministic but varied count
            name_hash = hash(governor_name) % 51  # 0-50
            target_quest_count = 75 + name_hash
            
        logger.info(f"Generating {target_quest_count} quests for {governor_name}")
        
        quests = []
        for i in range(target_quest_count):
            quest = self._generate_individual_quest(embodiment, i, target_quest_count)
            if quest:
                quests.append(quest)
                
        # Create quest tree
        quest_tree = QuestTree(
            governor_name=governor_name,
            total_quests=len(quests),
            quests=quests,
            difficulty_distribution=self._calculate_difficulty_distribution(quests),
            tradition_distribution=self._calculate_tradition_distribution(quests),
            quest_type_distribution=self._calculate_quest_type_distribution(quests)
        )
        
        self.quest_trees[governor_name] = quest_tree
        logger.info(f"Generated quest tree for {governor_name}: {len(quests)} quests")
        return quest_tree
    
    def _generate_individual_quest(self, embodiment: GovernorKnowledge, quest_index: int, total_quests: int) -> Optional[Quest]:
        """Generate a single quest for a governor"""
        profile = embodiment.profile.get('governor_profile', {})
        
        # Determine quest difficulty based on progression
        progression = quest_index / total_quests
        base_difficulty = int(1 + (progression * 25))  # 1-26 base range
        
        # Apply Aethyr modifier
        aethyr = profile.get('aethyr', 'LEA')
        aethyr_modifier = self.aethyr_modifiers.get(aethyr, 1.0)
        difficulty_level = min(30, int(base_difficulty * aethyr_modifier))
        
        # Select quest type based on progression and governor personality
        quest_type = self._select_quest_type(embodiment, progression)
        quest_template = self.quest_types[quest_type]
        
        # Select tradition focus from governor's knowledge base
        tradition_focus = self._select_tradition_focus(embodiment)
        
        # Generate quest content
        title = self._generate_quest_title(embodiment, quest_type, tradition_focus, difficulty_level)
        description = self._generate_quest_description(embodiment, quest_template, tradition_focus)
        
        # Calculate quest parameters
        energy_cost = min(6, quest_template['base_energy_cost'] + (difficulty_level // 10))
        reputation_reward = self._calculate_reputation_reward(difficulty_level, aethyr)
        required_reputation = self._calculate_required_reputation(difficulty_level)
        
        # Generate quest elements
        mystical_elements = self._generate_mystical_elements(embodiment, quest_type, tradition_focus)
        completion_criteria = self._generate_completion_criteria(quest_type, difficulty_level)
        failure_consequences = self._generate_failure_consequences(difficulty_level)
        
        # Add authentic content from lighthouse
        authentic_content = self._get_authentic_content(embodiment, tradition_focus)
        personality_flavor = self._add_personality_flavor(embodiment, quest_type)
        
        quest = Quest(
            id=f"{embodiment.name}_{quest_index:03d}",
            governor_name=embodiment.name,
            title=title,
            description=description,
            difficulty_level=difficulty_level,
            energy_cost=energy_cost,
            reputation_reward=reputation_reward,
            required_reputation=required_reputation,
            tradition_focus=tradition_focus,
            quest_type=quest_type,
            mystical_elements=mystical_elements,
            completion_criteria=completion_criteria,
            failure_consequences=failure_consequences,
            authentic_content=authentic_content,
            personality_flavor=personality_flavor
        )
        
        return quest
    
    def _select_quest_type(self, embodiment: GovernorKnowledge, progression: float) -> str:
        """Select quest type based on governor personality and progression"""
        profile = embodiment.profile.get('governor_profile', {})
        polar_traits = profile.get('polar_traits', {})
        
        # Early progression: meditation, study
        if progression < 0.3:
            return random.choice(['meditation', 'study'])
        # Mid progression: ritual, divination, service
        elif progression < 0.7:
            return random.choice(['ritual', 'divination', 'service'])
        # Late progression: creation, teaching, mastery
        else:
            return random.choice(['creation', 'teaching', 'mastery'])
    
    def _select_tradition_focus(self, embodiment: GovernorKnowledge) -> str:
        """Select tradition focus from governor's knowledge domains"""
        if not embodiment.lighthouse_knowledge:
            return 'hermetic_qabalah'  # Default fallback
            
        # Weight selection by knowledge domain size
        weighted_traditions = []
        for tradition, entries in embodiment.lighthouse_knowledge.items():
            weight = len(entries)
            weighted_traditions.extend([tradition] * weight)
            
        return random.choice(weighted_traditions) if weighted_traditions else 'hermetic_qabalah'
    
    def _generate_quest_title(self, embodiment: GovernorKnowledge, quest_type: str, tradition: str, difficulty: int) -> str:
        """Generate quest title incorporating governor's personality"""
        profile = embodiment.profile.get('governor_profile', {})
        name = profile.get('name', 'Unknown')
        aethyr = profile.get('aethyr', '')
        
        tradition_display = tradition.replace('_', ' ').title()
        
        title_templates = {
            'meditation': f"Meditative Communion with {name}",
            'ritual': f"Sacred Ritual of {tradition_display}",
            'study': f"Deep Study of {tradition_display} Mysteries",
            'divination': f"Oracular Wisdom through {tradition_display}",
            'service': f"Service in the Path of {tradition_display}",
            'creation': f"Creative Expression of {tradition_display}",
            'teaching': f"Teaching {tradition_display} Wisdom",
            'mastery': f"Mastery Trial of {aethyr} Aethyr"
        }
        
        base_title = title_templates.get(quest_type, f"{quest_type.title()} of {tradition_display}")
        
        # Add difficulty indicator for higher levels
        if difficulty > 20:
            base_title += " (Master Level)"
        elif difficulty > 15:
            base_title += " (Advanced)"
            
        return base_title
    
    def _generate_quest_description(self, embodiment: GovernorKnowledge, quest_template: Dict, tradition: str) -> str:
        """Generate detailed quest description"""
        profile = embodiment.profile.get('governor_profile', {})
        element = profile.get('element', 'Spirit')
        essence = profile.get('essence', '')
        
        # Use template with governor-specific elements
        base_description = quest_template['description_template'].format(
            element=element,
            tradition=tradition.replace('_', ' ').title(),
            divination_method=tradition.replace('_', ' ')
        )
        
        # Add governor's essence for flavor
        if essence:
            description = f"{base_description}. {essence[:100]}..."
        else:
            description = base_description
            
        return description
    
    def _calculate_reputation_reward(self, difficulty: int, aethyr: str) -> int:
        """Calculate reputation reward based on difficulty and Aethyr tier"""
        base_reward = max(1, difficulty // 2)
        
        # Aethyr tier multipliers
        tier_multipliers = {
            'TEX': 3.0, 'ARN': 2.8, 'ZOM': 2.6, 'PAZ': 2.4,  # Transcendence
            'LIT': 2.2, 'MAZ': 2.0, 'DEO': 1.8, 'ZID': 1.6,  # Mastery
            'ZIP': 1.4, 'ZAX': 1.2, 'ICH': 1.1, 'LOE': 1.0,  # Development
        }
        
        multiplier = tier_multipliers.get(aethyr, 1.0)
        return int(base_reward * multiplier)
    
    def _calculate_required_reputation(self, difficulty: int) -> int:
        """Calculate required reputation to unlock quest"""
        if difficulty <= 5:
            return 0
        elif difficulty <= 10:
            return 10
        elif difficulty <= 15:
            return 25
        elif difficulty <= 20:
            return 50
        elif difficulty <= 25:
            return 75
        else:
            return 100
    
    def _generate_mystical_elements(self, embodiment: GovernorKnowledge, quest_type: str, tradition: str) -> List[str]:
        """Generate mystical elements for the quest"""
        profile = embodiment.profile.get('governor_profile', {})
        element = profile.get('element', 'Spirit')
        aethyr = profile.get('aethyr', '')
        
        elements = [f"{aethyr.lower()}_energy", f"{element.lower()}_attunement"]
        
        type_elements = {
            'meditation': ['inner_silence', 'divine_communion'],
            'ritual': ['sacred_symbols', 'ceremonial_tools'],
            'divination': ['oracular_wisdom', 'prophetic_insight'],
            'service': ['compassionate_action', 'spiritual_guidance'],
            'creation': ['divine_inspiration', 'creative_manifestation'],
            'teaching': ['wisdom_transmission', 'spiritual_mentorship'],
            'mastery': ['transcendent_understanding', 'cosmic_awareness']
        }
        
        elements.extend(type_elements.get(quest_type, ['spiritual_development']))
        return elements
    
    def _generate_completion_criteria(self, quest_type: str, difficulty: int) -> List[str]:
        """Generate completion criteria for the quest"""
        base_criteria = {
            'meditation': ['Maintain focused attention', 'Receive clear guidance'],
            'ritual': ['Perform all steps precisely', 'Maintain sacred intention'],
            'study': ['Demonstrate understanding', 'Apply knowledge practically'],
            'divination': ['Receive clear divination', 'Interpret meaning accurately'],
            'service': ['Help others meaningfully', 'Embody spiritual principles'],
            'creation': ['Complete creative work', 'Express spiritual insight'],
            'teaching': ['Convey knowledge clearly', 'Inspire spiritual growth'],
            'mastery': ['Demonstrate advanced skill', 'Achieve transcendent state']
        }
        
        criteria = base_criteria.get(quest_type, ['Complete primary objective'])
        
        if difficulty > 15:
            criteria.append('Achieve advanced level of mastery')
        if difficulty > 25:
            criteria.append('Transcend ordinary limitations')
            
        return criteria
    
    def _generate_failure_consequences(self, difficulty: int) -> List[str]:
        """Generate failure consequences"""
        consequences = ['No reputation gain']
        
        if difficulty > 10:
            consequences.append('Extended cooldown period')
        if difficulty > 20:
            consequences.append('Temporary reputation penalty')
        if difficulty > 25:
            consequences.append('Spiritual purification required')
            
        return consequences
    
    def _get_authentic_content(self, embodiment: GovernorKnowledge, tradition: str) -> str:
        """Get authentic content from lighthouse knowledge"""
        if tradition not in embodiment.lighthouse_knowledge:
            return "Draw upon the deep wisdom of the mystical traditions."
            
        entries = embodiment.lighthouse_knowledge[tradition]
        if not entries:
            return "Explore the mysteries of this sacred tradition."
            
        # Select a relevant entry
        selected_entry = random.choice(entries)
        content = selected_entry.get('content', selected_entry.get('description', ''))
        
        # Truncate to reasonable length
        if len(content) > 200:
            content = content[:200] + "..."
            
        return f"Authentic Context: {content}"
    
    def _add_personality_flavor(self, embodiment: GovernorKnowledge, quest_type: str) -> str:
        """Add governor's personality flavor to the quest"""
        profile = embodiment.profile.get('governor_profile', {})
        polar_traits = profile.get('polar_traits', {})
        
        approach = polar_traits.get('baseline_approach', 'Guiding')
        tone = polar_traits.get('baseline_tone', 'Wise')
        virtues = polar_traits.get('virtues', [])
        
        virtue_text = f"embodying {', '.join(virtues[:2])}" if virtues else "with divine wisdom"
        
        return f"{embodiment.name} approaches this {quest_type} quest through {approach.lower()}, speaking with a {tone.lower()} tone and {virtue_text}."
    
    def _calculate_difficulty_distribution(self, quests: List[Quest]) -> Dict[str, int]:
        """Calculate difficulty distribution for quest tree"""
        distribution = {'beginner': 0, 'intermediate': 0, 'advanced': 0, 'master': 0}
        
        for quest in quests:
            if quest.difficulty_level <= 8:
                distribution['beginner'] += 1
            elif quest.difficulty_level <= 16:
                distribution['intermediate'] += 1
            elif quest.difficulty_level <= 24:
                distribution['advanced'] += 1
            else:
                distribution['master'] += 1
                
        return distribution
    
    def _calculate_tradition_distribution(self, quests: List[Quest]) -> Dict[str, int]:
        """Calculate tradition distribution for quest tree"""
        distribution = {}
        for quest in quests:
            tradition = quest.tradition_focus
            distribution[tradition] = distribution.get(tradition, 0) + 1
        return distribution
    
    def _calculate_quest_type_distribution(self, quests: List[Quest]) -> Dict[str, int]:
        """Calculate quest type distribution for quest tree"""
        distribution = {}
        for quest in quests:
            quest_type = quest.quest_type
            distribution[quest_type] = distribution.get(quest_type, 0) + 1
        return distribution
    
    def generate_all_quest_trees(self) -> Dict[str, QuestTree]:
        """Generate quest trees for all governors"""
        logger.info("Generating quest trees for all governors...")
        
        for governor_name in self.embodiment_system.embodiments.keys():
            self.generate_quest_tree(governor_name)
            
        logger.info(f"Generated quest trees for {len(self.quest_trees)} governors")
        return self.quest_trees
    
    def export_quest_trees(self, output_path: str = "governor_quest_trees.json"):
        """Export all quest trees to JSON"""
        export_data = {}
        
        for governor_name, quest_tree in self.quest_trees.items():
            export_data[governor_name] = {
                'governor_name': quest_tree.governor_name,
                'total_quests': quest_tree.total_quests,
                'difficulty_distribution': quest_tree.difficulty_distribution,
                'tradition_distribution': quest_tree.tradition_distribution,
                'quest_type_distribution': quest_tree.quest_type_distribution,
                'quests': [
                    {
                        'id': quest.id,
                        'title': quest.title,
                        'description': quest.description,
                        'difficulty_level': quest.difficulty_level,
                        'energy_cost': quest.energy_cost,
                        'reputation_reward': quest.reputation_reward,
                        'required_reputation': quest.required_reputation,
                        'tradition_focus': quest.tradition_focus,
                        'quest_type': quest.quest_type,
                        'mystical_elements': quest.mystical_elements,
                        'completion_criteria': quest.completion_criteria,
                        'failure_consequences': quest.failure_consequences,
                        'authentic_content': quest.authentic_content,
                        'personality_flavor': quest.personality_flavor
                    }
                    for quest in quest_tree.quests
                ]
            }
            
        with open(output_path, 'w', encoding='utf-8') as f:
            json.dump(export_data, f, indent=2, ensure_ascii=False)
            
        total_quests = sum(tree.total_quests for tree in self.quest_trees.values())
        logger.info(f"Exported {len(export_data)} quest trees with {total_quests} total quests to {output_path}")

def main():
    """Main function to generate governor quest trees"""
    from governor_ai_embodiment import main as create_embodiments
    
    logger.info("Creating governor AI embodiments...")
    embodiment_system = create_embodiments()
    
    logger.info("Generating governor quest trees...")
    quest_generator = GovernorQuestGenerator(embodiment_system)
    quest_trees = quest_generator.generate_all_quest_trees()
    
    # Export quest trees
    quest_generator.export_quest_trees()
    
    # Display summary
    total_quests = sum(tree.total_quests for tree in quest_trees.values())
    logger.info(f"\n=== QUEST GENERATION COMPLETE ===")
    logger.info(f"Total Governors: {len(quest_trees)}")
    logger.info(f"Total Quests Generated: {total_quests}")
    logger.info(f"Average Quests per Governor: {total_quests / len(quest_trees):.1f}")
    
    return quest_generator

if __name__ == "__main__":
    main()
